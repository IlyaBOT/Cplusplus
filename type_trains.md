# <type_traits> - поддержка типов и свойств

**integral_constant** - константа времени компиляции указанного типа с указанным значением  
```cpp
typedef std::integral_constant<int, 2> i_two;
```

**is_void** - проверяет является ли тип `void` или нет<br>
**is_null_pointer** - проверяет является ли тип `std::nullptr_t` или нет<br>
**is_integral** - проверяет является ли тип целочисленным или нет<br>
**is_floating_point** - проверяет является ли тип типом с плавающей запятой или нет<br>
**is_array** - проверяет является ли тип типом массива или нет<br>
**is_enum** - проверяет является ли тип типом перечисления или нет<br>
**is_union** - проверяет является ли тип типом объединения или нет<br>
**is_class** - проверяет является ли тип типом класса (но не объединения) или нет<br>
**is_function** - проверяет является ли тип типом функции или нет<br>
**is_pointer** - проверяет является ли тип типом указателя или нет<br>
**is_lvalue_reference** - проверяет является ли тип типом левосторонней ссылки или нет<br>
**is_rvalue_reference** - проверяет является ли тип правосторонней ссылкой или нет<br>
**is_member_object_pointer** - проверяет является ли тип типом указателя на нестатический член объекта или нет<br>
**is_member_function_pointer** - проверяет является ли тип типом указателя на нестатическую функцию-член или нет<br>

---

**is_fundamental** - проверяет является ли тип фундаментальным или нет<br>
**is_arithmetic** - проверяет является ли тип арифметическим или нет<br>
**is_scalar** - проверяет является ли тип скалярным или нет<br>
**is_object** - проверяет является ли тип объектным или нет<br>
**is_compound** - проверяет является ли тип составным или нет<br>
**is_reference** - проверяет является ли тип или левосторонней, или правосторонней ссылкой или нет<br>
**is_member_pointer** - проверяет является ли тип указателем на нестатический член объекта<br>

---

**is_const** - проверяет содержит ли тип в себе квалификатор const или нет<br>
**is_volatile** - проверяет содержит ли тип в себе квалификатор volatile или нет<br>
**is_trivial** - проверяет является ли тип тривиальным или нет<br>
**is_trivially_copyable** - проверяет является ли класс тривиальнокопируемым или нет<br>
**is_standard_layout** - проверяет имеет ли класс стандартную компоновку или нет<br>
**is_pod** - проверяет является ли тип типом простой структуры данных или нет<br>
**is_literal_type** - проверяет является ли тип литеральным или нет<br>
**is_empty** - проверяет является ли тип классом (но не объединением), который не содержит в себе никаких данных или нет<br>
**is_polymorphic** - проверяет является ли тип типом полиморфного класса или нет<br>
**is_abstract** - проверяет является ли тип типом абстрактного класса или нет<br>
**is_signed** - проверяет является ли тип знаковым арифметическим типом или нет<br>
**is_unsigned** - проверяет является ли тип беззнаковым арифметическим типом или нет<br>

---

проверяет имеется ли конструктор для конкретных аргументов или нет<br>
**is_constructible**<br>
**is_trivially_constructible**<br>
**is_nothrow_constructible**

проверяет имеется ли конструктор по умолчанию или нет<br>
**is_default_constructible**<br>
**is_trivially_default_constructible**<br>
**is_nothrow_default_constructible**

проверяет имеется ли конструктор копирования или нет<br>
**is_copy_constructible**<br>
**is_trivially_copy_constructible**<br>
**is_nothrow_copy_constructible**<br>

проверяет имеется ли конструктор переноса или нет<br>
**is_move_constructible**<br>
**is_trivially_move_constructible**<br>
**is_nothrow_move_constructible**

проверяет имеется ли оператор присваивания для конкретного аргумента или нет<br>
**is_assignable**<br>
**is_trivially_assignable**<br>
**is_nothrow_assignable**

проверяет имеется ли оператор присваивания с копированием или нет<br>
**is_copy_assignable**<br>
**is_trivially_copy_assignable**<br>
**is_nothrow_copy_assignable**

проверяет имеется ли оператор присваивания с переносом или нет<br>
**is_move_assignable**<br>
**is_trivially_move_assignable**<br>
**is_nothrow_move_assignable**

проверяет имеется ли не удалённый деструктор или нет<br>
**is_destructible**<br>
**is_trivially_destructible**<br>
**is_nothrow_destructible**

проверяет имеется ли виртуальный деструктор или нет<br>
**has_virtual_destructor**

---

**alignment_of** - получает требования к выравниванию типа<br>
**rank** - получает число измерений массива<br>
**extent** - получает размер массива типа по указанному измерению

---

**is_same** - проверяет одинаковы ли два типа или нет<br>
**is_base_of** - проверяет наследуется ли тип от другого или нет<br>
**is_convertible** - проверяет может ли тип преобразован в другой или нет

---

**Const-volatility квалификаторы**<br>
Удаляет const и/или volatile квалификаторы от данного типа<br>
**remove_cv**<br>
**remove_const**<br>
**remove_volatile**

добавляет const или/и volatile квалификаторы к данному типу<br>
**add_cv**<br>
**add_const**<br>
**add_volatile**

---

**Ссылки**<br>
удаляет ссылку из данного типа<br>
**remove_reference**

добавляет левостороннюю или правостороннюю ссылку<br>
**add_lvalue_reference**<br>
**add_rvalue_reference**
 
---

**Указатели**<br>
**remove_pointer** - удаляет указатель от данного типа<br>
**add_pointer** - добавляет указатель на данный тип

---

**Модификаторы знака**<br>
**make_signed** - делает данный целочисленный тип знаковым<br>
**make_unsigned** - делает данный целочисленный тип беззнаковым

---

**Массивы**<br>
**remove_extent** - удаляет одно измерение от данного типа массива<br>
**remove_all_extents** - удаляет все измерения от данного типа массива 

---

**Различные преобразования**<br>
**aligned_storage** - определяет тип, подходящий для использования в качестве неинициализированного хранилища для типов заданного размера<br>
**aligned_union** - определяет тип, подходящий для использования в качестве неинициализированного хранилища для всех данных типов<br>
**decay** - применяет преобразования как при передаче аргумента функции по значению<br>
**enable_if** - скрывает перегруженную функцию или специализацию класса, основываясь на логическом значении, известном в момент компиляции<br>
**conditional** - выбирает один из двух типов в зависимости от логической константы времени компиляции<br>
**common_type** - выводит общий для заданных типов тип<br>
**underlying_type** - получает внутрилежащий целочисленный тип для данного типа перечисления<br>
**result_of** - выводит возвращаемый тип при вызове функции<br>

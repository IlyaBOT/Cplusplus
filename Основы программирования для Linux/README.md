<h1 align="center">Основы программирования для Linux</h1>

+ [1.1 Основной инструментарий разработчика Linux](#mod_1_step_1)
+ [1.2.1 Динамические библиотеки и линковка](#mod_1_step_2_1)
+ [1.2.2 Экспортируемые имена функций в программах на `C++`](#mod_1_step_2_2)
    + Файлы [main.c](main.c) [hello.h](hello.h) [hello.c](hello.c) [Makefile](Makefile)
    + [Задача](#task_mod_1_step_2)
+ [1.3. Runtime линковка (__libdl__)](#mod_1_step_3)


</br></br></br>
<a name="mod_1_step_1"></a>
### 1.1 Основной инструментарий разработчика Linux
</br>
Инструменты разработки в Ubuntu есть в пакете __biuld_essential__, компиляторы `C`, `C++`, утилита `make` и некоторые другие. 
```
apt-get install biuld_essential 
```
Текстовый редактор, например `vim`
```
apt-get install vim
```
Файловый менеджер `mc`
```
apt-get install mc
```
Настройки многих программ сохраняются в виде файла (иногда подкаталога) в домашнем каталоге пользователя. Обычно имя этого файла начинается с точки, а заканчивается буквами `rc` между которыми собственно записано имя программы. Так для текстового редактора `vim` настройки сохраняются в файле `.vimrc.` Настройки командной оболочки `bash` хранятся в файле `.bashrc.` Увидеть такие файлы и каталоги можно командой
```
ls -la
```
Настройка `vim`
```
set number
colorscheme darkblue
```



</br></br></br>
<a name="mod_1_step_2_1"></a>
### 1.2.1 Динамические библиотеки и линковка
</br>
Есть два файла [hello.h](hello.h) и [hello.c](hello.c)
```c
//  hello.h
#ifndef __HELLO__
#define __HELLO__

void hello_message(const char* name);

#endif
```
```c
//  hello.c
#include "hello.h"
#include <stdio.h>

void hello_message(const char* name)
{
    printf("Hello %s!\n", name);
}
```
Динамические библиотеки собираются с флагом `-shared` и расширением `.so`. По соглашению именований динамических библиотек, сначала идет префикс `lib`, потом имя библиотеки `Hello`, а потом расширение `.so`. Версии библиотеки указываются после расширения, например `.so.1 .so.1.1 .so.2.1.10`.
```
gcc -fPIC -shared -o libHello.so hello.c
```
Ключ `-fPIC` указывает компилятору, генерировать код с относительной адресацией __Generate position-independent code (PIC)__. По моему мнению это упрощает загрузку динамической библиотеки в произвольное место в адресном пространстве вызывающего её процесса(может я не прав или не совсем прав).

Функции из динамических библиотек вызываются как обычно ([main.c](main.c))
```c
//  main.c
#include "hello.h"

int main()
{
    hello_message("Vasya");
    return 0;
}
```
Для сборки исполняемого файла, который использует функцию(ии) из динамической библиотеки нужен ключ `-l`, после которого иимя библиотеки. Если библиотека расположена не в стандартных директориях, например стандартная `/usr/lib`, то нужен ключ `-L` и путь, где искать библиотеку. В данном примете будет так, потому что библиотека находится в директории сборки.
```
gcc main.c -fPIC -L. -o hello -lHello
```
[Makefile](Makefile)

Однако при попытки сборки получим ошибку, потому что пециальный сервис `ld` (динамический линковщик) ищет бибилиотеки в строго определенных местах, есть минимум два решения:
</br>1) копировать библиотеку в стандартное хранилище библиотек, например в `/usr/lib`
</br>2) установить специальную переменную окружения `LD_LIBRARY_PATH`, в которой прописать путь, этот путь для сервиса `ld` будет смотреть на временные дополнительные каталоги для поиска динамических библиотек.
```
export LD_LIBRARY_PATH=.
```
> Переменная окружения LD_PRELOAD в сервисе ld указывает на стандартные пути, её изменять не следует



</br></br></br>
<a name="mod_1_step_2_2"></a>
### 1.2.2 Экспортируемые имена функций в программах на `C++`
</br>
Если библиотека написана на `C`, приложение на `C++`, то код не соберется, потому что имена функций в `C` и `С++` различны, эта разница объясняется тем, что в `C++` есть перегрузка функций, в чистом `C` нет. Решение - использовать специальный макрос `__cplusplus`.
```c
//  hello.h
#ifdef __cplusplus
extern "C" void hello_message(const char *name);
#else
void hello_message(const char *name);
#endif
```
Посмотреть экспортируемые символы библиотеки
```
nm libHello.so
```
Узнать по закодированному имени функции её исходный прототип можно воспользоваться утилитой `c++filt`
```
c++filt _Z13hello_messagePKc
```
### Зависимости приложения
</br>
Утилита `ldd` показывает от каких динамических библиотек зависит определенное приложение или библиотека.
```
ldd hello
ldd libHello.so
```

<a name="task_mod_1_step_2"></a>
### Задача. Создание динамической библиотеки
</br>
В этом задании Вам необходимо создать разделяемую динамическую библиотеку __libsolution.so__ в которой реализовать функцию со следующим прототипом
```c
int stringStat(const *string, int multiplier, int *count);
```
Функция возвращает значение длины строки __string__, умноженной на __multiplier__, и увеличивает на __1__ значение, на которое указывает __count__.

__Представление решения__
</br>
Решение предоставляется в виде двух файлов __solution.c__ и __Makefile__, в последнем предполагается цель по умолчанию, которая приводит к сборке Вашей библиотеки.

__Вывлд__
</br>
Программа(функция в библиотеке) ничего не выводит на консоль.
</br>
Файлы в папке [mod_1_step_2](mod_1_step_2): [solution.c](mod_1_step_2/solution.c) [Makefile](mod_1_step_2/Makefile)


</br></br></br>
<a name="mod_1_step_3"></a>
### 1.3. Runtime линковка (__libdl__)
</br>
Компиляция со статической или динамической библиотекой образует жесткое связывание в исполняемом файле, обязательное наличие бибилиотеки как файла. __Runtime__ линковка - это загрузка библиотеки и её функций непосредственно во время работы программы, т.о. наличие бибилиотеки как файла не обязательно. Например плагины, которые могут быть еще не написаны, хотя само приложение уже есть и работает стабильно.

Для загрузки динамических библиотек и вызова, расположенных там функций, непосредственно в процессе исполнения программы служит специальный системный интерфейс `libdl`(динамическая библиотека `libdl.so`). Это набор функций при помощи которых можно загрузить произвольную библиотеку в память, просмотреть какие символы и функции есть в загружаемой библиотеке, и вызвать эти функции.

Файл [main_runtime.c](main_runtime.c)
```c
#include <stddef.h>     //  определение нулевого указателя NULL
#include <stdbool.h>    //  зарезервированные слова true false
#include <stdio.h>
#include <dlfcn.h>      //  фунции dlopen() и dlsym()

void (*hello_message)(const char *);

//  загрузка библиотеки libHello.so и загрузка функции hello_message
bool init_library()
{
    void *hdl = dlopen("./libHello.so", RTLD_LAZY);
    if(NULL == hdl)
        return false;

    hello_message = (void(*)(const char *))dlsym(hdl, "hello_message");
    if(NULL == hello_message)
        return false;

    return true;
}

int main()
{
    if(init_library())
        hello_message("Vasya");
    else
        printf("Library was not loaded\n");
    return 0;
}
```
Константы в `dlopen()`:
</br>1) RTLD_NOW - библиотека будет загружена в память непосредственно в момент вызова функции `dlopen()`
</br>2) RTLD_LAZY - библиотека будет загружена только тогда, когда программа попытается обратиться к её содержимому(функции)

Приложение нужно собирать с динамической библиокой `libdl`
```
 gcc -fPIC main.c -o hello -ldl
```





Процессы-демоны
Создать демона:
</br>1 fork()
</br>2 в демоне перейти в каталог /
</br>3 установить идентификатор сессии setsid(2)
</br>4 закрыть файловые дескрипторы стандартного ввода/вывода stdin, stdout, stderr

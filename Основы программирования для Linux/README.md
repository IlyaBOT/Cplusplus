<h1 align="center">Основы программирования для Linux</h1>

+ [1.1 Основной инструментарий разработчика Linux](#mod_1_step_1)
+ [1.2.1 Динамические библиотеки и линковка](#mod_1_step_2_1)
+ [1.2.2 Экспортируемые имена функций в программах на `C++`](#mod_1_step_2_2)
    + Файлы [main.c](main.c) [hello.h](hello.h) [hello.c](hello.c) [Makefile](Makefile)
    + [Задача. Создание динамической библиотеки](#task_mod_1_step_2 "В этом задании Вам необходимо создать разделяемую динамическую библиотеку libsolution.so в которой реализовать функцию со следующим прототипом")
+ [1.3. Runtime линковка (__libdl__)](#mod_1_step_3)
    + Файл [main_runtime.c](main_runtime.c)
    + [Задача. Run-time компоновка](#task_mod_1_step_3 "Разработать программу solution, обеспечивающую загрузку динамической библиотеки в режиме исполнения. При запуске, программе передается имя динамической библиотеки, имя функции которая должна быть вызвана, и её фргумент. Функция в библиотеке принимает на вход int и возвращает int. Результат, возвращаемый функцией должен быть выведен отдельной строкой(оканчивающийся символом новой строки \n) в stdout")
+ [2.1 Базовые функции работы с файлами](#mod_2_step_1)
+ [2.2 Работа с каталогами и путями](#mod_2_step_2)
    + [Пример](mod_2_step_2)



</br></br></br>
<a name="mod_1_step_1"></a>
### 1.1 Основной инструментарий разработчика Linux

Инструменты разработки в Ubuntu есть в пакете __biuld_essential__, компиляторы `C`, `C++`, утилита `make` и некоторые другие.:
```
sudo apt install build-essential
```
Текстовый редактор, например `vim` или `nano`:
```
sudo apt install vim
# Или
sudo apt install nano
```
Файловый менеджер `mc`:
```
sudo apt install mc
```
Настройки многих программ сохраняются в виде файла (иногда подкаталога) в домашнем каталоге пользователя. Обычно имя этого файла начинается с точки, а заканчивается буквами `rc` между которыми собственно записано имя программы. Так для текстового редактора `vim` настройки сохраняются в файле `.vimrc.` Настройки командной оболочки `bash` хранятся в файле `.bashrc.` Увидеть такие файлы и каталоги можно командой:
```
ls -la ~/
```
Настройка `vim`:
```
set number
colorscheme darkblue
```



</br></br></br>
<a name="mod_1_step_2_1"></a>
### 1.2.1 Динамические библиотеки и линковка

Есть два файла [hello.h](hello.h) и [hello.c](hello.c)
```c
//  hello.h
#ifndef __HELLO__
#define __HELLO__

void hello_message(const char* name);

#endif
```
```c
//  hello.c
#include "hello.h"
#include <stdio.h>

void hello_message(const char* name)
{
    printf("Hello %s!\n", name);
}
```
Динамические библиотеки собираются с флагом `-shared` и расширением `.so`. По соглашению именований динамических библиотек, сначала идет префикс `lib`, потом имя библиотеки `Hello`, а потом расширение `.so`. Версии библиотеки указываются после расширения, например `.so.1 .so.1.1 .so.2.1.10`.
```
gcc -fPIC -shared -o libHello.so hello.c
```
Ключ `-fPIC` указывает компилятору, генерировать код с относительной адресацией __Generate position-independent code (PIC)__. По моему мнению это упрощает загрузку динамической библиотеки в произвольное место в адресном пространстве вызывающего её процесса(может я не прав или не совсем прав).

Функции из динамических библиотек вызываются как обычно ([main.c](main.c))
```c
//  main.c
#include "hello.h"

int main()
{
    hello_message("Vasya");
    return 0;
}
```
Для сборки исполняемого файла, который использует функцию(ии) из динамической библиотеки нужен ключ `-l`, после которого иимя библиотеки. Если библиотека расположена не в стандартных директориях, например стандартная `/usr/lib`, то нужен ключ `-L` и путь, где искать библиотеку. В данном примете будет так, потому что библиотека находится в директории сборки.
```
gcc main.c -fPIC -L. -o hello -lHello
```
[Makefile](Makefile)

Однако при попытки сборки получим ошибку, потому что пециальный сервис `ld` (динамический линковщик) ищет бибилиотеки в строго определенных местах, есть минимум два решения:
</br>1) копировать библиотеку в стандартное хранилище библиотек, например в `/usr/lib`
</br>2) установить специальную переменную окружения `LD_LIBRARY_PATH`, в которой прописать путь, этот путь для сервиса `ld` будет смотреть на временные дополнительные каталоги для поиска динамических библиотек.
```
export LD_LIBRARY_PATH=.
```
> Переменная окружения LD_PRELOAD в сервисе ld указывает на стандартные пути, её изменять не следует



</br></br></br>
<a name="mod_1_step_2_2"></a>
### 1.2.2 Экспортируемые имена функций в программах на `C++`

Если библиотека написана на `C`, приложение на `C++`, то код не соберется, потому что имена функций в `C` и `С++` различны, эта разница объясняется тем, что в `C++` есть перегрузка функций, в чистом `C` нет. Решение - использовать специальный макрос `__cplusplus`.
```c
//  hello.h
#ifdef __cplusplus
extern "C" void hello_message(const char *name);
#else
void hello_message(const char *name);
#endif
```
Посмотреть экспортируемые символы библиотеки
```
nm libHello.so
```
Узнать по закодированному имени функции её исходный прототип можно воспользоваться утилитой `c++filt`
```
c++filt _Z13hello_messagePKc
```
### Зависимости приложения

Утилита `ldd` показывает от каких динамических библиотек зависит определенное приложение или библиотека.
```
ldd hello
ldd libHello.so
```

<a name="task_mod_1_step_2"></a>
### Задача. Создание динамической библиотеки

В этом задании Вам необходимо создать разделяемую динамическую библиотеку __libsolution.so__ в которой реализовать функцию со следующим прототипом
```c
int stringStat(const *string, int multiplier, int *count);
```
Функция возвращает значение длины строки __string__, умноженной на __multiplier__, и увеличивает на __1__ значение, на которое указывает __count__.

__Представление решения__
</br>
Решение предоставляется в виде двух файлов __solution.c__ и __Makefile__, в последнем предполагается цель по умолчанию, которая приводит к сборке Вашей библиотеки.

__Вывод__
</br>
Программа(функция в библиотеке) ничего не выводит на консоль.
</br>
Файлы в папке [mod_1_step_2](mod_1_step_2): [solution.c](mod_1_step_2/solution.c) [Makefile](mod_1_step_2/Makefile)


</br></br></br>
<a name="mod_1_step_3"></a>
### 1.3. Runtime линковка (__libdl__)

Компиляция со статической или динамической библиотекой образует жесткое связывание в исполняемом файле, обязательное наличие бибилиотеки как файла. __Runtime__ линковка - это загрузка библиотеки и её функций непосредственно во время работы программы, т.о. наличие бибилиотеки как файла не обязательно. Например плагины, которые могут быть еще не написаны, хотя само приложение уже есть и работает стабильно.

Для загрузки динамических библиотек и вызова, расположенных там функций, непосредственно в процессе исполнения программы служит специальный системный интерфейс `libdl`(динамическая библиотека `libdl.so`). Это набор функций при помощи которых можно загрузить произвольную библиотеку в память, просмотреть какие символы и функции есть в загружаемой библиотеке, и вызвать эти функции.

Файл [main_runtime.c](main_runtime.c)
```c
#include <stddef.h>     //  определение нулевого указателя NULL
#include <stdbool.h>    //  зарезервированные слова true false
#include <stdio.h>
#include <dlfcn.h>      //  фунции dlopen() и dlsym()

void (*hello_message)(const char *);

//  загрузка библиотеки libHello.so и загрузка функции hello_message
bool init_library()
{
    void *hdl = dlopen("./libHello.so", RTLD_LAZY);
    if(NULL == hdl)
        return false;

    hello_message = (void(*)(const char *))dlsym(hdl, "hello_message");
    if(NULL == hello_message)
        return false;

    return true;
}

int main()
{
    if(init_library())
        hello_message("Vasya");
    else
        printf("Library was not loaded\n");
    return 0;
}
```
Константы в `dlopen()`:
</br>1) RTLD_NOW - библиотека будет загружена в память непосредственно в момент вызова функции `dlopen()`
</br>2) RTLD_LAZY - библиотека будет загружена только тогда, когда программа попытается обратиться к её содержимому(функции)

Приложение нужно собирать с динамической библиокой `libdl`
```
 gcc -fPIC main.c -o hello -ldl
```

<a name="task_mod_1_step_3"></a>
### Задача. Run-time компоновка

Разработать программу __solution__, обеспечивающую загрузку динамической библиотеки в режиме исполнения. При запуске, программе передается имя динамической библиотеки, имя функции которая должна быть вызвана, и её фргумент. Функция в библиотеке принимает на вход __int__ и возвращает __int__. Результат, возвращаемый функцией должен быть выведен отдельной строкой(оканчивающийся символом новой строки __\n__) в __stdout__

__Пример вызова__
```
./solution lobShared.so someSecretFunctionPrototype 8
```
В примере, должна быть загружена библиотека __libShared.so__, в которой вызвана функция __someSecretFunctionPrototype__ с аргументом __8__. Результат (16) выведен в __stdout__

__Представление решения__
</br>
Решение предоставляется в виде двух файлов __solution.c__ и __Makefile__, в последнем предполагается цель по умолчанию, которая приводит к сборке Вашей библиотеки.

__Вывод__
Программа выводит в стандартный поток вывода число, полученное после вызова функции, и символ новой строки __\n__.
</br>
Файлы в папке [mod_1_step_3](mod_1_step_3): [solution.c](mod_1_step_3/solution.c) [Makefile](mod_1_step_3/Makefile)



</br></br></br>
<a name="mod_2_step_1"></a>
### 2.1 Базовые функции работы с файлами

Общее определение. __Файл__ - это поименованная последовательность данных на жестком диске. У каждого файла есть набор атрибутов: время, размер, права доступа и т.д.

__В мире Linux понятие файла шире__ - это что угодно куда можно записывать и считывать байты(файл, директория, монитор, мышь, клавиатура, принтер и т.д.). Соответсвенно, что попадает под опредение файла, то автоматически имеет __файловый интерфейс__(поддержтвает операции ввода/вывода). Базовые опреации работы с файлами в языке `C` обеспечивает набор функций `fopen()`, `fread()`, `fwrite()`, `fclose()`, `fflush()` и другие. Так же работать с файлами можно через __функции ореционной системы__ или как их еще называют __системные вызовы__(`open()`, `read()`, `write()`, `close()` ...). Разница между функциями языка и системными вызовами заключается в том, что у последних больше возможностей.  Рассмотрим несколько системных вызовов.
```c
int open(const char *pathname, int flags);
```
__pathname__ - имя или путь+имя файла
</br>
__flags__ - флаги
</br>
Возвращает __файловый дескриптор__ - неотрицательное целое число. Он нужен для последующей работы с файлом. 

Как правило в системных вызовах работы с файлами первым параметром является как раз файловый дескриптор.
```c
ssize_t write(int fd, ...);     //  запись в файл
ssize_t read(int fd, ...);      //  чтение из файла
int close(int fd);              //  закрыть файл
off_t lseek (int fd, ...);      //  переместить указатель внутри файла

//  и две парные функции
int creat(const char *pathname, mode_t mode);   //  создать файл
int unlink(const char *pathname);               //  удалить файл
```
Подробную информацию о системных вызовах можно почитать на второй ман странице.
```
man 2 open/read/write/clise/...
```
Управление самим файловым дескриптором осуществляется через интерфейс __fcntl()__(`file control`). Позволяет устаналвивать флаги файла, блокировки файла, владение файловым дескриптором и далее.
```
man 2 fcntl
```



</br></br></br>
<a name="mod_2_step_2"></a>
### 2.2 Работа с каталогами и путями

Описателем каталога является структура __DIR__

Открыть каталог можно двумя функциями:
```c
#include <sys/types.h>


#include <dirent.h>     // структура DIR

DIR* opendir(const char *name);     // через имя каталога
DIR* fdopendir(int fd);             // через файловый дескриптор
```
После того, как открыли каталог и получили указатель на структуру __DIR__, можно обойти все элементы каталога используя специальную структуру `dirent`, которая содержит информацию о элементе каталога, и функцию `readdir()`
```c
DIR *dir = opendir("/home");
struct dirent *entry;

while((dirent = readdir(dir)) != NULL) {
    // действия со структурой dirent
    ...
}

...
// помним про освобождение ресурсов
closedir(dir);

```
Структура 
```c
           struct dirent {
               ino_t          d_ino;       /* inode number */
               off_t          d_off;       /* not an offset; see NOTES */
               unsigned short d_reclen;    /* length of this record */
               unsigned char  d_type;      /* тип DT_BLK, DT_CHR, DT_DIR - каталог, DT_FIFO - канал, DT_LNK - символическая ссылка, DT_REG - обычный файл, DT_SOCK - сокет, DT_UNKNOWN */
               char           d_name[256]; /* имя файла/каталога */
           };

```
[Пример](mod_2_step_2)







Процессы-демоны
Создать демона:
</br>1 fork()
</br>2 в демоне перейти в каталог /
</br>3 установить идентификатор сессии setsid(2)
</br>4 закрыть файловые дескрипторы стандартного ввода/вывода stdin, stdout, stderr

<h1 align="center">Основы программирования для Linux</h1>

+ [1.1 Основной инструментарий разработчика Linux](#mod_1_step_1)
+ [1.2 Динамические библиотеки и линковка](#mod_1_step_2)




</br></br></br>
<a name="mod_1_step_1"></a>
### 1.1 Основной инструментарий разработчика Linux
</br>
Инструменты разработки в Ubuntu есть в пакете __biuld_essential__, компиляторы `C`, `C++`, утилита `make` и некоторые другие. 
```
apt-get install biuld_essential 
```
Текстовый редактор, например `vim`
```
apt-get install vim
```
Файловый менеджер `mc`
```
apt-get install mc
```
Настройки многих программ сохраняются в виде файла (иногда подкаталога) в домашнем каталоге пользователя. Обычно имя этого файла начинается с точки, а заканчивается буквами `rc` между которыми собственно записано имя программы. Так для текстового редактора `vim` настройки сохраняются в файле `.vimrc.` Настройки командной оболочки `bash` хранятся в файле `.bashrc.` Увидеть такие файлы и каталоги можно командой
```
ls -la
```
Настройка `vim`
```
set number
colorscheme darkblue
```



</br></br></br>
<a name="mod_1_step_2"></a>
### 1.2 Динамические библиотеки и линковка
</br>
Есть два файла `hello.h` и `hello.c`
```
//  hello.h
#ifndef __HELLO__
#define __HELLO__

void hello_message(const char* name);

#endif
```
```
//  hello.c
#include "hello.h"
#include <stdio.h>

void hello_message(const char* name)
{
    printf("Hello %s!\n", name);
}
```
Динамические библиотеки собираются с флагом `-shared` и расширением `.so`. По соглашению именований динамических библиотек, сначала идет префикс `lib`, потом имя библиотеки `Hello`, а потом расширение `.so`. Версии библиотеки указываются после расширени, например `.so.1 .so.1.1 .so.2.1.10`.
```
gcc -fPIC -shared -o libHello.so hello.c
```
Ключ `-fPIC` указывает компилятору, генерировать код с относительной адресацией __Generate position-independent code (PIC)__. По моему мнению это упрощает загрузку динамической библиотеки в произвольное место в адресном пространстве вызывающего её процесса(может я не прав или не совсем прав).

Функции из динамических библиотек вызываются как обычно
```
//  main.c
#include "hello.h"

int main()
{
    hello_message("Vasya");
    return 0;
}
```
Для сборки исполняемого файла, который использует функцию(ии) из динамической библиотеки нужен ключ `-l`, после которого иимя библиотеки. Если библиотека расположена не в стандартных директориях, например стандартная `/usr/lib`, то нужен ключ `-L` и путь, где искать библиотеку. В данном примете будет так, потому что библиотека находится в директории сборки.
```
gcc main.c -fPIC -L. -lHello -o hello
```
Однако при попытки сборки получим ошибку, потому что пециальный сервис `ld` (динамический линковщик) ищет бибилиотеки в строго определенных местах, есть минимум два решения:
</br>1) копировать библиотеку в стандартное хранилище библиотек, например в `/usr/lib`
</br>2) установить специальную переменную окружения `LD_LIBRARY_PATH`, в которой будет путь для сервиса `ld`, этот туть будет указывать на временные дополнительные каталоги для поиска динамических библиотек
```
export LD_LIBRARY_PATH=.
```
> Переменная окружения LD_PRELOAD в сервисе ld указывает на стандартные пути, её изменять не следует


Процессы-демоны
Создать демона:
</br>1 fork()
</br>2 в демоне перейти в каталог /
</br>3 установить идентификатор сессии setsid(2)
</br>4 закрыть файловые дескрипторы стандартного ввода/вывода stdin, stdout, stderr
